// Homomesh.cpp : Defines the entry point for the console application.
// Command line program to generate cuboid mesh with scaling for FEA
// Output is compatible with Abaqus
// Written by Peter Falkingham, 7/1/2011
// mailto: peter.falkingham@manchester.ac.uk
//

#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
using namespace std;

int main(int argc, char *argv[])
{
	//declare variables
	//ten given variables:
	float dx, tx, dz, tz, dy, ty, sf;
	int ndx, ndz, ndy;
	//calculated variables
	int halfndx, halfndz, nld, nlx, nly, elNo;
	int xels, zels, yels, lx, lz, ly, counter, c1, c2, c3;
	float halfdx, halfdz, halftx, halftz;
	float delxsize, delysize, delzsize;
	float currentSize, currentElSize;
	float* xarray = NULL;
	float* yarray = NULL;
	float* zarray = NULL;

	//READ VARIABLES
	ifstream input;
	input.open ("input.txt");
	input >> dx;
	input >> dz;
	input >> tx;
	input >> tz;
	input >> dy;
	input >> ty;
	input >> sf;
	input >> ndx;
	input >> ndz;
	input >> ndy;

	//Calculate number of required outer els
	halfdx = dx/2;
	halfdz = dz/2;
	halftx = tx/2;
	halftz = tz/2;
	halfndx = ndx/2;
	halfndz = ndz/2;

	delxsize = dx/ndx;
	delzsize = dz/ndz;
	delysize = dy/ndy;

	//for x
	currentSize = halfdx;
	elNo = halfndx;
	currentElSize = delxsize;

	while(currentSize < halftx){
		currentElSize = currentElSize*sf;
		currentSize = currentSize+currentElSize;
		elNo++;
	}
	xels = elNo;


	//for z
	currentSize = halfdz;
	elNo = halfndz;
	currentElSize = delzsize;

	while(currentSize < halftz){
		currentElSize = currentElSize*sf;
		currentSize = currentSize+currentElSize;
		elNo++;
	}
	zels = elNo;

	//for y
	currentSize = dy;
	elNo = ndy;
	currentElSize = delysize;

	while(currentSize < ty){
		currentElSize = currentElSize*sf;
		currentSize = currentSize+currentElSize;
		elNo++;
	}
	yels = elNo;

	//output for user
	cout << "*********************************\n";
	cout << "Homomesh - P L Falkingham\n";
	cout << "Karl is ...\n";  //edited to be PC 13/10/20
	cout << "*********************************\n";
	cout << "Total number of elements will be: " << xels*2*zels*2*yels <<'\n';
	cout << "*********************************\n";

	//create arrays of x, y, and z, coords.
	xarray = new float[xels*2+1];
	zarray = new float[zels*2+1];
	yarray = new float[yels+1];

	lx = xels-halfndx;
	lz = zels-halfndz;
	xarray[xels] = zarray[zels] = yarray[0] = 0;


	//fill known quarter x
	for(counter=1; counter<=halfndx; counter++){
		xarray[xels+counter] = xarray[xels+counter-1]+delxsize;
	}

	for(counter=xels+halfndx+1; counter < xels*2+1; counter++){
		currentSize = xarray[counter-1]-xarray[counter-2];
		xarray[counter] = currentSize*sf + xarray[counter-1];
	}

	//fill unknown half x
	for(counter=-1; counter>=halfndx*-1; counter--){
		xarray[xels+counter] = xarray[xels+counter+1]-delxsize;
	}
	for(counter=xels-halfndx-1; counter >=0; counter--){
		currentSize = xarray[counter+1]-xarray[counter+2];
		xarray[counter] = currentSize*sf + xarray[counter+1];
	}

	//fill known quarter z
	for(counter=1; counter<=halfndz; counter++){
		zarray[zels+counter] = zarray[zels+counter-1]+delzsize;
	}
	for(counter=zels+halfndz+1; counter < zels*2+1; counter++){
		currentSize = zarray[counter-1]-zarray[counter-2];
		zarray[counter] = currentSize*sf + zarray[counter-1];
	}

	//fill unknown half z
	for(counter=-1; counter>=halfndz*-1; counter--){
		zarray[zels+counter] = zarray[zels+counter+1]-delzsize;
	}
	for(counter=zels-halfndz-1; counter >=0; counter--){
		currentSize = zarray[counter+1]-zarray[counter+2];
		zarray[counter] = currentSize*sf + zarray[counter+1];
	}
	//fill y
	for(counter=1; counter<=ndy; counter++){
		yarray[counter] = (yarray[counter-1]+delysize);
	}
	counter = ndy;
	while(counter < yels+1){
		counter++;
		currentSize = yarray[counter-1]-yarray[counter-2];
		yarray[counter] = (currentSize*sf + yarray[counter-1]);
	}


	ofstream output;
	output.open ("soilmesh.inp");
	output << "*Heading\n** Job name: Job-1 Model name: HomoMesh\n** Generated by: HomoMesh (PFalkingham)\n";
	output << "*Preprint, echo=NO, model=NO, history=NO, contact=NO\n**\n** PARTS\n**\n";
	output << "*Part, name=soil\n*Node\n";
	counter =1;
	for(c2=0; c2<=yels;c2++){
		for(c1=0; c1<=zels*2; c1++){
			for(c3=0;c3<=xels*2;c3++){
				output << counter << ",\t "<< xarray[c3] << ",\t " << yarray[c2]*-1 << ",\t " << zarray[c1] << "\n";
				counter ++;
			}
		}
	}
	output << "*Element, type=C3D8R\n";
	counter =1;
	for(c2=1; c2<=yels; c2++){
		for(c1=1; c1<=zels*2; c1++){
			for(c3=1; c3<=xels*2; c3++){
				output << counter << ",\t ";
				output << counter+c1-1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1) << ",\t " ;
				output << counter+c1-1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1)+ (xels*2+1)*(zels*2+1) << ",\t " ;
				output << counter+c1-1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1)*(zels*2+1)<< ",\t " ;
				output << counter+c1-1 + (c2-1)*((xels*2+zels*2)+1)<< ",\t " ;
				output << counter+c1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1)<< ",\t "  ;
				output << counter+c1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1)+ (xels*2+1)*(zels*2+1)<< ",\t ";
				output << counter+c1 + (c2-1)*((xels*2+zels*2)+1) + (xels*2+1)*(zels*2+1)<< ",\t ";
				output << counter+c1 + (c2-1)*((xels*2+zels*2)+1) << "\n";
				counter++;
			}
		}
	}
	output << "*End Part\n";
	output << "**\n";
	output << "**\n";
	output << "ASSEMBLY";
	output << "**\n";
	output << "*Assembly, name=Assembly\n";
	output << "**\n";
	output << "*Instance, name=Part-1-1, part=soil\n";
	output << "*End Instance\n";
	output << "**\n";
	output << "*End Assembly\n";

	return 0;
}

